{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport { Platform, StyleSheet, Animated, BackHandler, Dimensions, Easing, I18nManager, TouchableWithoutFeedback, View, ScrollView, findNodeHandle } from 'react-native';\nimport { withTheme } from '../../core/theming';\nimport Portal from '../Portal/Portal';\nimport Surface from '../Surface'; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nimport MenuItem from './MenuItem';\nimport { APPROX_STATUSBAR_HEIGHT } from '../../constants'; // Minimum padding between the edge of the screen and the menu\n\nconst SCREEN_INDENT = 8; // From https://material.io/design/motion/speed.html#duration\n\nconst ANIMATION_DURATION = 250; // From the 'Standard easing' section of https://material.io/design/motion/speed.html#easing\n\nconst EASING = Easing.bezier(0.4, 0, 0.2, 1);\n/**\n * Menus display a list of choices on temporary elevated surfaces. Their placement varies based on the element that opens them.\n *\n *  <div class=\"screenshots\">\n *   <img class=\"medium\" src=\"screenshots/menu-1.png\" />\n *   <img class=\"medium\" src=\"screenshots/menu-2.png\" />\n * </div>\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { View } from 'react-native';\n * import { Button, Menu, Divider, Provider } from 'react-native-paper';\n *\n * const MyComponent = () => {\n *   const [visible, setVisible] = React.useState(false);\n *\n *   const openMenu = () => setVisible(true);\n *\n *   const closeMenu = () => setVisible(false);\n *\n *   return (\n *     <Provider>\n *       <View\n *         style={{\n *           paddingTop: 50,\n *           flexDirection: 'row',\n *           justifyContent: 'center',\n *         }}>\n *         <Menu\n *           visible={visible}\n *           onDismiss={closeMenu}\n *           anchor={<Button onPress={openMenu}>Show menu</Button>}>\n *           <Menu.Item onPress={() => {}} title=\"Item 1\" />\n *           <Menu.Item onPress={() => {}} title=\"Item 2\" />\n *           <Divider />\n *           <Menu.Item onPress={() => {}} title=\"Item 3\" />\n *         </Menu>\n *       </View>\n *     </Provider>\n *   );\n * };\n *\n * export default MyComponent;\n * ```\n */\n\nclass Menu extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      rendered: this.props.visible,\n      top: 0,\n      left: 0,\n      menuLayout: {\n        width: 0,\n        height: 0\n      },\n      anchorLayout: {\n        width: 0,\n        height: 0\n      },\n      opacityAnimation: new Animated.Value(0),\n      scaleAnimation: new Animated.ValueXY({\n        x: 0,\n        y: 0\n      })\n    });\n\n    _defineProperty(this, \"anchor\", null);\n\n    _defineProperty(this, \"menu\", null);\n\n    _defineProperty(this, \"isCoordinate\", anchor => ! /*#__PURE__*/React.isValidElement(anchor) && typeof (anchor === null || anchor === void 0 ? void 0 : anchor.x) === 'number' && typeof (anchor === null || anchor === void 0 ? void 0 : anchor.y) === 'number');\n\n    _defineProperty(this, \"measureMenuLayout\", () => new Promise(resolve => {\n      if (this.menu) {\n        this.menu.measureInWindow((x, y, width, height) => {\n          resolve({\n            x,\n            y,\n            width,\n            height\n          });\n        });\n      }\n    }));\n\n    _defineProperty(this, \"measureAnchorLayout\", () => new Promise(resolve => {\n      const {\n        anchor\n      } = this.props;\n\n      if (this.isCoordinate(anchor)) {\n        resolve({\n          x: anchor.x,\n          y: anchor.y,\n          width: 0,\n          height: 0\n        });\n        return;\n      }\n\n      if (this.anchor) {\n        this.anchor.measureInWindow((x, y, width, height) => {\n          resolve({\n            x,\n            y,\n            width,\n            height\n          });\n        });\n      }\n    }));\n\n    _defineProperty(this, \"updateVisibility\", async () => {\n      // Menu is rendered in Portal, which updates items asynchronously\n      // We need to do the same here so that the ref is up-to-date\n      await Promise.resolve();\n\n      if (this.props.visible) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    });\n\n    _defineProperty(this, \"isBrowser\", () => Platform.OS === 'web' && 'document' in global);\n\n    _defineProperty(this, \"focusFirstDOMNode\", el => {\n      if (el && this.isBrowser()) {\n        // When in the browser, we want to focus the first focusable item on toggle\n        // For example, when menu is shown, focus the first item in the menu\n        // And when menu is dismissed, send focus back to the button to resume tabbing\n        const node = findNodeHandle(el);\n        const focusableNode = node.querySelector( // This is a rough list of selectors that can be focused\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\n        focusableNode === null || focusableNode === void 0 ? void 0 : focusableNode.focus();\n      }\n    });\n\n    _defineProperty(this, \"handleDismiss\", () => {\n      if (this.props.visible) {\n        this.props.onDismiss();\n      }\n\n      return true;\n    });\n\n    _defineProperty(this, \"handleKeypress\", e => {\n      if (e.key === 'Escape') {\n        this.props.onDismiss();\n      }\n    });\n\n    _defineProperty(this, \"attachListeners\", () => {\n      BackHandler.addEventListener('hardwareBackPress', this.handleDismiss);\n      Dimensions.addEventListener('change', this.handleDismiss);\n      this.isBrowser() && document.addEventListener('keyup', this.handleKeypress);\n    });\n\n    _defineProperty(this, \"removeListeners\", () => {\n      BackHandler.removeEventListener('hardwareBackPress', this.handleDismiss);\n      Dimensions.removeEventListener('change', this.handleDismiss);\n      this.isBrowser() && document.removeEventListener('keyup', this.handleKeypress);\n    });\n\n    _defineProperty(this, \"show\", async () => {\n      const windowLayout = Dimensions.get('window');\n      const [menuLayout, anchorLayout] = await Promise.all([this.measureMenuLayout(), this.measureAnchorLayout()]); // When visible is true for first render\n      // native views can be still not rendered and\n      // measureMenuLayout/measureAnchorLayout functions\n      // return wrong values e.g { x:0, y: 0, width: 0, height: 0 }\n      // so we have to wait until views are ready\n      // and rerun this function to show menu\n\n      if (!windowLayout.width || !windowLayout.height || !menuLayout.width || !menuLayout.height || !anchorLayout.width && !this.isCoordinate(this.props.anchor) || !anchorLayout.height && !this.isCoordinate(this.props.anchor)) {\n        requestAnimationFrame(this.show);\n        return;\n      }\n\n      this.setState(() => ({\n        left: anchorLayout.x,\n        top: anchorLayout.y,\n        anchorLayout: {\n          height: anchorLayout.height,\n          width: anchorLayout.width\n        },\n        menuLayout: {\n          width: menuLayout.width,\n          height: menuLayout.height\n        }\n      }), () => {\n        this.attachListeners();\n        const {\n          animation\n        } = this.props.theme;\n        Animated.parallel([Animated.timing(this.state.scaleAnimation, {\n          toValue: {\n            x: menuLayout.width,\n            y: menuLayout.height\n          },\n          duration: ANIMATION_DURATION * animation.scale,\n          easing: EASING,\n          useNativeDriver: true\n        }), Animated.timing(this.state.opacityAnimation, {\n          toValue: 1,\n          duration: ANIMATION_DURATION * animation.scale,\n          easing: EASING,\n          useNativeDriver: true\n        })]).start(({\n          finished\n        }) => {\n          if (finished) {\n            this.focusFirstDOMNode(this.menu);\n          }\n        });\n      });\n    });\n\n    _defineProperty(this, \"hide\", () => {\n      this.removeListeners();\n      const {\n        animation\n      } = this.props.theme;\n      Animated.timing(this.state.opacityAnimation, {\n        toValue: 0,\n        duration: ANIMATION_DURATION * animation.scale,\n        easing: EASING,\n        useNativeDriver: true\n      }).start(({\n        finished\n      }) => {\n        if (finished) {\n          this.setState({\n            menuLayout: {\n              width: 0,\n              height: 0\n            },\n            rendered: false\n          });\n          this.state.scaleAnimation.setValue({\n            x: 0,\n            y: 0\n          });\n          this.focusFirstDOMNode(this.anchor);\n        }\n      });\n    });\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (nextProps.visible && !prevState.rendered) {\n      return {\n        rendered: true\n      };\n    }\n\n    return null;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.visible !== this.props.visible) {\n      this.updateVisibility();\n    }\n  }\n\n  componentWillUnmount() {\n    this.removeListeners();\n  }\n\n  render() {\n    const {\n      visible,\n      anchor,\n      contentStyle,\n      style,\n      children,\n      theme,\n      statusBarHeight,\n      onDismiss,\n      overlayAccessibilityLabel\n    } = this.props;\n    const {\n      rendered,\n      menuLayout,\n      anchorLayout,\n      opacityAnimation,\n      scaleAnimation\n    } = this.state;\n    let {\n      left,\n      top\n    } = this.state; // I don't know why but on Android measure function is wrong by 24\n\n    const additionalVerticalValue = Platform.select({\n      android: statusBarHeight,\n      default: 0\n    });\n    const scaleTransforms = [{\n      scaleX: scaleAnimation.x.interpolate({\n        inputRange: [0, menuLayout.width],\n        outputRange: [0, 1]\n      })\n    }, {\n      scaleY: scaleAnimation.y.interpolate({\n        inputRange: [0, menuLayout.height],\n        outputRange: [0, 1]\n      })\n    }];\n    const windowLayout = Dimensions.get('window'); // We need to translate menu while animating scale to imitate transform origin for scale animation\n\n    const positionTransforms = []; // Check if menu fits horizontally and if not align it to right.\n\n    if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {\n      positionTransforms.push({\n        translateX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [-(menuLayout.width / 2), 0]\n        })\n      }); // Check if menu position has enough space from left side\n\n      if (left < SCREEN_INDENT) {\n        left = SCREEN_INDENT;\n      }\n    } else {\n      positionTransforms.push({\n        translateX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [menuLayout.width / 2, 0]\n        })\n      });\n      left += anchorLayout.width - menuLayout.width;\n      const right = left + menuLayout.width; // Check if menu position has enough space from right side\n\n      if (right > windowLayout.width - SCREEN_INDENT) {\n        left = windowLayout.width - SCREEN_INDENT - menuLayout.width;\n      }\n    } // If the menu is larger than available vertical space,\n    // calculate the height of scrollable view\n\n\n    let scrollableMenuHeight = 0; // Check if the menu should be scrollable\n\n    if ( // Check if the menu overflows from bottom side\n    top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And bottom side of the screen has more space than top side\n    top <= windowLayout.height - top) {\n      // Scrollable menu should be below the anchor (expands downwards)\n      scrollableMenuHeight = windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;\n    } else if ( // Check if the menu overflows from bottom side\n    top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And top side of the screen has more space than bottom side\n    top >= windowLayout.height - top && // And menu overflows from top side\n    top <= menuLayout.height - anchorLayout.height + SCREEN_INDENT - additionalVerticalValue) {\n      // Scrollable menu should be above the anchor (expands upwards)\n      scrollableMenuHeight = top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;\n    } // Scrollable menu max height\n\n\n    scrollableMenuHeight = scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT ? windowLayout.height - 2 * SCREEN_INDENT : scrollableMenuHeight; // Menu is typically positioned below the element that generates it\n    // So first check if it fits below the anchor (expands downwards)\n\n    if ( // Check if menu fits vertically\n    top <= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue || // Or if the menu overflows from bottom side\n    top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And bottom side of the screen has more space than top side\n    top <= windowLayout.height - top) {\n      positionTransforms.push({\n        translateY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0]\n        })\n      }); // Check if menu position has enough space from top side\n\n      if (top < SCREEN_INDENT) {\n        top = SCREEN_INDENT;\n      }\n    } else {\n      positionTransforms.push({\n        translateY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0]\n        })\n      });\n      top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);\n      const bottom = top + (scrollableMenuHeight || menuLayout.height) + additionalVerticalValue; // Check if menu position has enough space from bottom side\n\n      if (bottom > windowLayout.height - SCREEN_INDENT) {\n        top = scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT ? -SCREEN_INDENT * 2 : windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue;\n      }\n    }\n\n    const shadowMenuContainerStyle = {\n      opacity: opacityAnimation,\n      transform: scaleTransforms,\n      borderRadius: theme.roundness,\n      ...(scrollableMenuHeight ? {\n        height: scrollableMenuHeight\n      } : {})\n    };\n    const positionStyle = {\n      top: this.isCoordinate(anchor) ? top : top + additionalVerticalValue,\n      ...(I18nManager.isRTL ? {\n        right: left\n      } : {\n        left\n      })\n    };\n    return /*#__PURE__*/React.createElement(View, {\n      ref: ref => {\n        this.anchor = ref;\n      },\n      collapsable: false\n    }, this.isCoordinate(anchor) ? null : anchor, rendered ? /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(TouchableWithoutFeedback, {\n      accessibilityLabel: overlayAccessibilityLabel,\n      accessibilityRole: \"button\",\n      onPress: onDismiss\n    }, /*#__PURE__*/React.createElement(View, {\n      style: StyleSheet.absoluteFill\n    })), /*#__PURE__*/React.createElement(View, {\n      ref: ref => {\n        this.menu = ref;\n      },\n      collapsable: false,\n      accessibilityViewIsModal: visible,\n      style: [styles.wrapper, positionStyle, style],\n      pointerEvents: visible ? 'box-none' : 'none',\n      onAccessibilityEscape: onDismiss\n    }, /*#__PURE__*/React.createElement(Animated.View, {\n      style: {\n        transform: positionTransforms\n      }\n    }, /*#__PURE__*/React.createElement(Surface, {\n      style: [styles.shadowMenuContainer, shadowMenuContainerStyle, contentStyle]\n    }, scrollableMenuHeight && /*#__PURE__*/React.createElement(ScrollView, null, children) || /*#__PURE__*/React.createElement(React.Fragment, null, children))))) : null);\n  }\n\n}\n\n_defineProperty(Menu, \"Item\", MenuItem);\n\n_defineProperty(Menu, \"defaultProps\", {\n  statusBarHeight: APPROX_STATUSBAR_HEIGHT,\n  overlayAccessibilityLabel: 'Close menu'\n});\n\nconst styles = StyleSheet.create({\n  wrapper: {\n    position: 'absolute'\n  },\n  shadowMenuContainer: {\n    opacity: 0,\n    paddingVertical: 8,\n    elevation: 8\n  }\n});\nexport default withTheme(Menu);","map":{"version":3,"sources":["Menu.tsx"],"names":["SCREEN_INDENT","ANIMATION_DURATION","EASING","Easing","Menu","React","MenuItem","statusBarHeight","overlayAccessibilityLabel","getDerivedStateFromProps","nextProps","prevState","rendered","top","left","menuLayout","width","height","anchorLayout","opacityAnimation","Animated","scaleAnimation","x","y","componentDidUpdate","prevProps","componentWillUnmount","anchor","resolve","Promise","Platform","el","node","findNodeHandle","focusableNode","e","BackHandler","Dimensions","document","windowLayout","requestAnimationFrame","animation","toValue","duration","easing","useNativeDriver","finished","render","additionalVerticalValue","android","default","scaleTransforms","scaleX","inputRange","outputRange","scaleY","positionTransforms","translateX","right","scrollableMenuHeight","translateY","bottom","shadowMenuContainerStyle","opacity","transform","borderRadius","theme","positionStyle","ref","onDismiss","StyleSheet","absoluteFill","styles","visible","wrapper","position","shadowMenuContainer","paddingVertical","elevation","withTheme"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Platform,\n  StyleProp,\n  StyleSheet,\n  Animated,\n  BackHandler,\n  Dimensions,\n  Easing,\n  I18nManager,\n  LayoutRectangle,\n  TouchableWithoutFeedback,\n  View,\n  ViewStyle,\n  ScrollView,\n  findNodeHandle,\n} from 'react-native';\n\nimport { withTheme } from '../../core/theming';\nimport type { $Omit } from '../../types';\nimport Portal from '../Portal/Portal';\nimport Surface from '../Surface';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport MenuItem, { MenuItem as _MenuItem } from './MenuItem';\nimport { APPROX_STATUSBAR_HEIGHT } from '../../constants';\n\ntype Props = {\n  /**\n   * Whether the Menu is currently visible.\n   */\n  visible: boolean;\n  /**\n   * The anchor to open the menu from. In most cases, it will be a button that opens the menu.\n   */\n  anchor: React.ReactNode | { x: number; y: number };\n  /**\n   * Extra margin to add at the top of the menu to account for translucent status bar on Android.\n   * If you are using Expo, we assume translucent status bar and set a height for status bar automatically.\n   * Pass `0` or a custom value to and customize it.\n   * This is automatically handled on iOS.\n   */\n  statusBarHeight?: number;\n  /**\n   * Callback called when Menu is dismissed. The `visible` prop needs to be updated when this is called.\n   */\n  onDismiss: () => void;\n  /**\n   * Accessibility label for the overlay. This is read by the screen reader when the user taps outside the menu.\n   */\n  overlayAccessibilityLabel?: string;\n  /**\n   * Content of the `Menu`.\n   */\n  children: React.ReactNode;\n  /**\n   * Style of menu's inner content.\n   */\n  contentStyle?: StyleProp<ViewStyle>;\n  style?: StyleProp<ViewStyle>;\n  /**\n   * @optional\n   */\n  theme: ReactNativePaper.Theme;\n};\n\ntype Layout = $Omit<$Omit<LayoutRectangle, 'x'>, 'y'>;\n\ntype State = {\n  rendered: boolean;\n  top: number;\n  left: number;\n  menuLayout: Layout;\n  anchorLayout: Layout;\n  opacityAnimation: Animated.Value;\n  scaleAnimation: Animated.ValueXY;\n};\n\n// Minimum padding between the edge of the screen and the menu\nconst SCREEN_INDENT = 8;\n// From https://material.io/design/motion/speed.html#duration\nconst ANIMATION_DURATION = 250;\n// From the 'Standard easing' section of https://material.io/design/motion/speed.html#easing\nconst EASING = Easing.bezier(0.4, 0, 0.2, 1);\n\n/**\n * Menus display a list of choices on temporary elevated surfaces. Their placement varies based on the element that opens them.\n *\n *  <div class=\"screenshots\">\n *   <img class=\"medium\" src=\"screenshots/menu-1.png\" />\n *   <img class=\"medium\" src=\"screenshots/menu-2.png\" />\n * </div>\n *\n * ## Usage\n * ```js\n * import * as React from 'react';\n * import { View } from 'react-native';\n * import { Button, Menu, Divider, Provider } from 'react-native-paper';\n *\n * const MyComponent = () => {\n *   const [visible, setVisible] = React.useState(false);\n *\n *   const openMenu = () => setVisible(true);\n *\n *   const closeMenu = () => setVisible(false);\n *\n *   return (\n *     <Provider>\n *       <View\n *         style={{\n *           paddingTop: 50,\n *           flexDirection: 'row',\n *           justifyContent: 'center',\n *         }}>\n *         <Menu\n *           visible={visible}\n *           onDismiss={closeMenu}\n *           anchor={<Button onPress={openMenu}>Show menu</Button>}>\n *           <Menu.Item onPress={() => {}} title=\"Item 1\" />\n *           <Menu.Item onPress={() => {}} title=\"Item 2\" />\n *           <Divider />\n *           <Menu.Item onPress={() => {}} title=\"Item 3\" />\n *         </Menu>\n *       </View>\n *     </Provider>\n *   );\n * };\n *\n * export default MyComponent;\n * ```\n */\nclass Menu extends React.Component<Props, State> {\n  // @component ./MenuItem.tsx\n  static Item = MenuItem;\n\n  static defaultProps = {\n    statusBarHeight: APPROX_STATUSBAR_HEIGHT,\n    overlayAccessibilityLabel: 'Close menu',\n  };\n\n  static getDerivedStateFromProps(nextProps: Props, prevState: State) {\n    if (nextProps.visible && !prevState.rendered) {\n      return { rendered: true };\n    }\n\n    return null;\n  }\n\n  state = {\n    rendered: this.props.visible,\n    top: 0,\n    left: 0,\n    menuLayout: { width: 0, height: 0 },\n    anchorLayout: { width: 0, height: 0 },\n    opacityAnimation: new Animated.Value(0),\n    scaleAnimation: new Animated.ValueXY({ x: 0, y: 0 }),\n  };\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.visible !== this.props.visible) {\n      this.updateVisibility();\n    }\n  }\n\n  componentWillUnmount() {\n    this.removeListeners();\n  }\n\n  private anchor?: View | null = null;\n  private menu?: View | null = null;\n\n  private isCoordinate = (anchor: any): anchor is { x: number; y: number } =>\n    !React.isValidElement(anchor) &&\n    typeof anchor?.x === 'number' &&\n    typeof anchor?.y === 'number';\n\n  private measureMenuLayout = () =>\n    new Promise<LayoutRectangle>((resolve) => {\n      if (this.menu) {\n        this.menu.measureInWindow((x, y, width, height) => {\n          resolve({ x, y, width, height });\n        });\n      }\n    });\n\n  private measureAnchorLayout = () =>\n    new Promise<LayoutRectangle>((resolve) => {\n      const { anchor } = this.props;\n      if (this.isCoordinate(anchor)) {\n        resolve({ x: anchor.x, y: anchor.y, width: 0, height: 0 });\n        return;\n      }\n\n      if (this.anchor) {\n        this.anchor.measureInWindow((x, y, width, height) => {\n          resolve({ x, y, width, height });\n        });\n      }\n    });\n\n  private updateVisibility = async () => {\n    // Menu is rendered in Portal, which updates items asynchronously\n    // We need to do the same here so that the ref is up-to-date\n    await Promise.resolve();\n\n    if (this.props.visible) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  };\n\n  private isBrowser = () => Platform.OS === 'web' && 'document' in global;\n\n  private focusFirstDOMNode = (el: View | null | undefined) => {\n    if (el && this.isBrowser()) {\n      // When in the browser, we want to focus the first focusable item on toggle\n      // For example, when menu is shown, focus the first item in the menu\n      // And when menu is dismissed, send focus back to the button to resume tabbing\n      const node: any = findNodeHandle(el);\n      const focusableNode = node.querySelector(\n        // This is a rough list of selectors that can be focused\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n      );\n\n      focusableNode?.focus();\n    }\n  };\n\n  private handleDismiss = () => {\n    if (this.props.visible) {\n      this.props.onDismiss();\n    }\n    return true;\n  };\n\n  private handleKeypress = (e: KeyboardEvent) => {\n    if (e.key === 'Escape') {\n      this.props.onDismiss();\n    }\n  };\n\n  private attachListeners = () => {\n    BackHandler.addEventListener('hardwareBackPress', this.handleDismiss);\n    Dimensions.addEventListener('change', this.handleDismiss);\n\n    this.isBrowser() && document.addEventListener('keyup', this.handleKeypress);\n  };\n\n  private removeListeners = () => {\n    BackHandler.removeEventListener('hardwareBackPress', this.handleDismiss);\n    Dimensions.removeEventListener('change', this.handleDismiss);\n\n    this.isBrowser() &&\n      document.removeEventListener('keyup', this.handleKeypress);\n  };\n\n  private show = async () => {\n    const windowLayout = Dimensions.get('window');\n    const [menuLayout, anchorLayout] = await Promise.all([\n      this.measureMenuLayout(),\n      this.measureAnchorLayout(),\n    ]);\n\n    // When visible is true for first render\n    // native views can be still not rendered and\n    // measureMenuLayout/measureAnchorLayout functions\n    // return wrong values e.g { x:0, y: 0, width: 0, height: 0 }\n    // so we have to wait until views are ready\n    // and rerun this function to show menu\n    if (\n      !windowLayout.width ||\n      !windowLayout.height ||\n      !menuLayout.width ||\n      !menuLayout.height ||\n      (!anchorLayout.width && !this.isCoordinate(this.props.anchor)) ||\n      (!anchorLayout.height && !this.isCoordinate(this.props.anchor))\n    ) {\n      requestAnimationFrame(this.show);\n      return;\n    }\n\n    this.setState(\n      () => ({\n        left: anchorLayout.x,\n        top: anchorLayout.y,\n        anchorLayout: {\n          height: anchorLayout.height,\n          width: anchorLayout.width,\n        },\n        menuLayout: {\n          width: menuLayout.width,\n          height: menuLayout.height,\n        },\n      }),\n      () => {\n        this.attachListeners();\n\n        const { animation } = this.props.theme;\n        Animated.parallel([\n          Animated.timing(this.state.scaleAnimation, {\n            toValue: { x: menuLayout.width, y: menuLayout.height },\n            duration: ANIMATION_DURATION * animation.scale,\n            easing: EASING,\n            useNativeDriver: true,\n          }),\n          Animated.timing(this.state.opacityAnimation, {\n            toValue: 1,\n            duration: ANIMATION_DURATION * animation.scale,\n            easing: EASING,\n            useNativeDriver: true,\n          }),\n        ]).start(({ finished }) => {\n          if (finished) {\n            this.focusFirstDOMNode(this.menu);\n          }\n        });\n      }\n    );\n  };\n\n  private hide = () => {\n    this.removeListeners();\n\n    const { animation } = this.props.theme;\n    Animated.timing(this.state.opacityAnimation, {\n      toValue: 0,\n      duration: ANIMATION_DURATION * animation.scale,\n      easing: EASING,\n      useNativeDriver: true,\n    }).start(({ finished }) => {\n      if (finished) {\n        this.setState({ menuLayout: { width: 0, height: 0 }, rendered: false });\n        this.state.scaleAnimation.setValue({ x: 0, y: 0 });\n        this.focusFirstDOMNode(this.anchor);\n      }\n    });\n  };\n\n  render() {\n    const {\n      visible,\n      anchor,\n      contentStyle,\n      style,\n      children,\n      theme,\n      statusBarHeight,\n      onDismiss,\n      overlayAccessibilityLabel,\n    } = this.props;\n\n    const {\n      rendered,\n      menuLayout,\n      anchorLayout,\n      opacityAnimation,\n      scaleAnimation,\n    } = this.state;\n\n    let { left, top } = this.state;\n\n    // I don't know why but on Android measure function is wrong by 24\n    const additionalVerticalValue = Platform.select({\n      android: statusBarHeight,\n      default: 0,\n    });\n\n    const scaleTransforms = [\n      {\n        scaleX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [0, 1],\n        }),\n      },\n      {\n        scaleY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [0, 1],\n        }),\n      },\n    ];\n\n    const windowLayout = Dimensions.get('window');\n\n    // We need to translate menu while animating scale to imitate transform origin for scale animation\n    const positionTransforms = [];\n\n    // Check if menu fits horizontally and if not align it to right.\n    if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {\n      positionTransforms.push({\n        translateX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [-(menuLayout.width / 2), 0],\n        }),\n      });\n\n      // Check if menu position has enough space from left side\n      if (left < SCREEN_INDENT) {\n        left = SCREEN_INDENT;\n      }\n    } else {\n      positionTransforms.push({\n        translateX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [menuLayout.width / 2, 0],\n        }),\n      });\n\n      left += anchorLayout.width - menuLayout.width;\n\n      const right = left + menuLayout.width;\n      // Check if menu position has enough space from right side\n      if (right > windowLayout.width - SCREEN_INDENT) {\n        left = windowLayout.width - SCREEN_INDENT - menuLayout.width;\n      }\n    }\n\n    // If the menu is larger than available vertical space,\n    // calculate the height of scrollable view\n    let scrollableMenuHeight = 0;\n\n    // Check if the menu should be scrollable\n    if (\n      // Check if the menu overflows from bottom side\n      top >=\n        windowLayout.height -\n          menuLayout.height -\n          SCREEN_INDENT -\n          additionalVerticalValue &&\n      // And bottom side of the screen has more space than top side\n      top <= windowLayout.height - top\n    ) {\n      // Scrollable menu should be below the anchor (expands downwards)\n      scrollableMenuHeight =\n        windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;\n    } else if (\n      // Check if the menu overflows from bottom side\n      top >=\n        windowLayout.height -\n          menuLayout.height -\n          SCREEN_INDENT -\n          additionalVerticalValue &&\n      // And top side of the screen has more space than bottom side\n      top >= windowLayout.height - top &&\n      // And menu overflows from top side\n      top <=\n        menuLayout.height -\n          anchorLayout.height +\n          SCREEN_INDENT -\n          additionalVerticalValue\n    ) {\n      // Scrollable menu should be above the anchor (expands upwards)\n      scrollableMenuHeight =\n        top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;\n    }\n\n    // Scrollable menu max height\n    scrollableMenuHeight =\n      scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT\n        ? windowLayout.height - 2 * SCREEN_INDENT\n        : scrollableMenuHeight;\n\n    // Menu is typically positioned below the element that generates it\n    // So first check if it fits below the anchor (expands downwards)\n    if (\n      // Check if menu fits vertically\n      top <=\n        windowLayout.height -\n          menuLayout.height -\n          SCREEN_INDENT -\n          additionalVerticalValue ||\n      // Or if the menu overflows from bottom side\n      (top >=\n        windowLayout.height -\n          menuLayout.height -\n          SCREEN_INDENT -\n          additionalVerticalValue &&\n        // And bottom side of the screen has more space than top side\n        top <= windowLayout.height - top)\n    ) {\n      positionTransforms.push({\n        translateY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0],\n        }),\n      });\n\n      // Check if menu position has enough space from top side\n      if (top < SCREEN_INDENT) {\n        top = SCREEN_INDENT;\n      }\n    } else {\n      positionTransforms.push({\n        translateY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0],\n        }),\n      });\n\n      top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);\n\n      const bottom =\n        top +\n        (scrollableMenuHeight || menuLayout.height) +\n        additionalVerticalValue;\n\n      // Check if menu position has enough space from bottom side\n      if (bottom > windowLayout.height - SCREEN_INDENT) {\n        top =\n          scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT\n            ? -SCREEN_INDENT * 2\n            : windowLayout.height -\n              menuLayout.height -\n              SCREEN_INDENT -\n              additionalVerticalValue;\n      }\n    }\n\n    const shadowMenuContainerStyle = {\n      opacity: opacityAnimation,\n      transform: scaleTransforms,\n      borderRadius: theme.roundness,\n      ...(scrollableMenuHeight ? { height: scrollableMenuHeight } : {}),\n    };\n\n    const positionStyle = {\n      top: this.isCoordinate(anchor) ? top : top + additionalVerticalValue,\n      ...(I18nManager.isRTL ? { right: left } : { left }),\n    };\n\n    return (\n      <View\n        ref={(ref) => {\n          this.anchor = ref;\n        }}\n        collapsable={false}\n      >\n        {this.isCoordinate(anchor) ? null : anchor}\n        {rendered ? (\n          <Portal>\n            <TouchableWithoutFeedback\n              accessibilityLabel={overlayAccessibilityLabel}\n              accessibilityRole=\"button\"\n              onPress={onDismiss}\n            >\n              <View style={StyleSheet.absoluteFill} />\n            </TouchableWithoutFeedback>\n            <View\n              ref={(ref) => {\n                this.menu = ref;\n              }}\n              collapsable={false}\n              accessibilityViewIsModal={visible}\n              style={[styles.wrapper, positionStyle, style]}\n              pointerEvents={visible ? 'box-none' : 'none'}\n              onAccessibilityEscape={onDismiss}\n            >\n              <Animated.View style={{ transform: positionTransforms }}>\n                <Surface\n                  style={\n                    [\n                      styles.shadowMenuContainer,\n                      shadowMenuContainerStyle,\n                      contentStyle,\n                    ] as StyleProp<ViewStyle>\n                  }\n                >\n                  {(scrollableMenuHeight && (\n                    <ScrollView>{children}</ScrollView>\n                  )) || <React.Fragment>{children}</React.Fragment>}\n                </Surface>\n              </Animated.View>\n            </View>\n          </Portal>\n        ) : null}\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  wrapper: {\n    position: 'absolute',\n  },\n  shadowMenuContainer: {\n    opacity: 0,\n    paddingVertical: 8,\n    elevation: 8,\n  },\n});\n\nexport default withTheme(Menu);\n"]},"metadata":{},"sourceType":"module"}